/*
 * send raw serial data
 *
 * This sample demonstrates raw serial communications using a
 * SyncLink serial card. The companion sample receive-raw.c receives
 * raw serial data. Use both programs to send data between two serial cards
 * connected with a NULL modem (cross over cable) or other serial link.
 *
 * The sample is simple to clearly show basic programming concepts.
 * Use this code to start development of more complex applications.
 *
 * Overview:
 *
 * 1. open serial device (syscall open)
 * 2. configure serial device (syscall ioctl)
 * 3. send data to serial device (syscall write)
 *
 * For more information about SyncLink specific programming refer to
 * the Programming.txt file included with the SyncLink software package.
 *
 * Microgate and SyncLink are registered trademarks
 * of Microgate corporation.
 *
 * This code is released under the GNU General Public License (GPL)
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <memory.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <termios.h>
#include <errno.h>
#include <sys/time.h>

#include "synclink.h"

#ifndef N_HDLC
#define N_HDLC 13
#endif

/*
 * set base clock frequency in cycles per second
 *
 * Data clocks are generated by dividing a fixed base clock by a 16-bit integer.
 * GT family base clock default is 14745600 (14.7456MHz)
 *
 * Other base clocks (up to 33MHz) can be installed
 * at the factory by special order. Non default values require driver
 * configuration with the actual value so correct divisors are used for
 * a specified data rate.
 */
int set_base_clock(int fd, unsigned int freq)
{
	MGSL_PARAMS params;
	int rc;

	/* fields other than mode and clock_speed are ignored */
	params.mode = MGSL_MODE_BASE_CLOCK;
	params.clock_speed = freq;
	rc = ioctl(fd, MGSL_IOCSPARAMS, &params);
	if (rc < 0) {
		printf("set base clock frequency error=%d %s\n",
		       errno, strerror(errno));
	}
	return rc;
}

int main(int argc, char* argv[])
{
	int fd;
	int rc;
	int sigs, idle;
	int ldisc = N_HDLC;
	MGSL_PARAMS params;
	int size = 1024;
	unsigned char buf[1024];
	char *devname;
	struct timeval begin, end;

	if (argc > 1)
		devname = argv[1];
	else
		devname = "/dev/ttyUSB0";

	printf("send raw serial data on %s\n", devname);

	/* open serial device with O_NONBLOCK to ignore DCD input */
	fd = open(devname, O_RDWR | O_NONBLOCK, 0);
	if (fd < 0) {
		printf("open error=%d %s\n", errno, strerror(errno));
		return fd;
	}
	close(fd);
	fd = open(devname, O_RDWR | O_NONBLOCK, 0);
	if (fd < 0) {
		printf("open error=%d %s\n", errno, strerror(errno));
		return fd;
	}

	/*
	 * set N_HDLC line discipline (used for synchronous modes)
	 *
	 * A line discipline is a software layer between a tty device driver
	 * and user application that performs intermediate processing,
	 * formatting, and buffering of data.
	 */
	/*
	rc = ioctl(fd, TIOCSETD, &ldisc);
	if(rc < 0) {
		printf("set line discipline error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}
	*/

	/* required only if custom base clock (not 14745600) installed */
//	if (set_base_clock(fd, 32000000) < 0)
//		return rc;

	/* get current device parameters */
	rc = ioctl(fd, MGSL_IOCGPARAMS, &params);
	if (rc < 0) {
		printf("ioctl(MGSL_IOCGPARAMS) error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	/*
	 * modify device parameters
	 *
	 * raw synchronous mode, loopback disabled, NRZ encoding
	 * data clocks sourced from clock input pins
	 * output 9600bps clock on auxclk output pin
	 * disable hardware CRC generation/checking
	 */

	params.mode = MGSL_MODE_RAW;
	params.loopback = 0;
	params.flags = HDLC_FLAG_RXC_BRG + HDLC_FLAG_TXC_BRG;
	// params.encoding = HDLC_ENCODING_NRZ;
	params.encoding = HDLC_ENCODING_BIPHASE_LEVEL;
	params.clock_speed = 100000;
	params.crc_type = HDLC_CRC_NONE;

	/* set current device parameters */
	rc = ioctl(fd, MGSL_IOCSPARAMS, &params);
	if (rc < 0) {
		printf("ioctl(MGSL_IOCSPARAMS) error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	// /* set transmit idle pattern (sent when no send data available) */
	// idle = HDLC_TXIDLE_ONES;
	// rc = ioctl(fd, MGSL_IOCSTXIDLE, idle);
	// if (rc < 0) {
	//	printf("ioctl(MGSL_IOCSTXIDLE) error=%d %s\n",
	//	       errno, strerror(errno));
	//	return rc;
	//}

	/* initialize send buffer to all zeros */
	memset(buf, 0, size);

	/* set device to blocking mode for reads and writes */
	fcntl(fd, F_SETFL, fcntl(fd,F_GETFL) & ~O_NONBLOCK);

	printf("Turn on RTS and DTR serial outputs\n");
	sigs = TIOCM_RTS + TIOCM_DTR;
	rc = ioctl(fd, TIOCMBIS, &sigs);
	if(rc < 0) {
		printf("assert DTR/RTS error=%d %s\n", errno, strerror(errno));
		return rc;
	}

	while (1) {

		/*
		 * idle pattern is all 1s and data is all 0s to allow easy
		 * inspection of data received on remote card. Because raw serial mode
		 * has no synchronization, received data may appear bit shifted.
		 */
		gettimeofday(&begin, NULL);
		printf("Sending %d bytes\n", size);
		rc = write(fd, buf, size);
		if (rc < 0) {
			printf("write error=%d %s\n", errno, strerror(errno));
			return rc;
		}

		printf("wait for all data sent...\n");
		/* chose method to wait for all data sent: blocked or polling */
	#if 1
		/* block until all data sent */
		rc = tcdrain(fd);
		gettimeofday(&end, NULL);
	#else
		/* poll until all data sent */
		do {
			rc = ioctl(fd, TIOCOUTQ, &size);
			if (rc < 0) {
				printf("ioctl(TIOCOUTQ) error=%d %s\n",
				       errno, strerror(errno));
				break;
			}
		} while (size);
	#endif
		printf("all data sent\n");
		printf("It took %f second to write %d bytes\n", (end.tv_usec - begin.tv_usec)/1000000.0, size);

		/*
		 * Delay to allow sending of idle pattern and
		 * keep auxclk clock output active for 2 seconds to give remote receiver
		 * extra clock cycles for internal processing of received data.
		 * If an external device supplies data clocks, this is not needed.
		 */
		sleep(2);

		printf("Turn off RTS and DTR\n");
		sigs = TIOCM_RTS + TIOCM_DTR;
		rc = ioctl(fd, TIOCMBIC, &sigs);
		if (rc < 0) {
			printf("negate DTR/RTS error=%d %s\n", errno, strerror(errno));
			return rc;
		}
	}

	close(fd);

	return 0;
}

