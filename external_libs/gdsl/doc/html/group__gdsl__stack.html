<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gdsl: Stack manipulation module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>Stack manipulation module</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _gdsl_stack *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GDSL stack type.  <a href="#ged560443d2612fcdb10a55a51687cbbb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc</a> (const char *NAME, <a class="el" href="group__gdsl__types.html#g32a9b4e8b9665183c2741d28a5ced64f">gdsl_alloc_func_t</a> ALLOC_F, <a class="el" href="group__gdsl__types.html#g2c6b3f96b291b5b39d2799f93e350053">gdsl_free_func_t</a> FREE_F)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new stack.  <a href="#g226386196ca32ee4eae9441f9229a990"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gc115f451db17f6509048018bdef1ffe6">gdsl_stack_free</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a stack.  <a href="#gc115f451db17f6509048018bdef1ffe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g2ad434c6a6cd2e66033195a9cee5919f">gdsl_stack_flush</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a stack.  <a href="#g2ad434c6a6cd2e66033195a9cee5919f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gf8e7609d8785a3c5f458b996aa42baef">gdsl_stack_get_name</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Getsthe name of a stack.  <a href="#gf8e7609d8785a3c5f458b996aa42baef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g240a364616309e15eb374469af80a019">gdsl_stack_get_size</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of a stack.  <a href="#g240a364616309e15eb374469af80a019"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g89fc03e3da09672b366c6e3f1dd3bb4c">gdsl_stack_get_growing_factor</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the growing factor of a stack.  <a href="#g89fc03e3da09672b366c6e3f1dd3bb4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#gf6a258d8f3ee5206d682d799316314b1">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g05718ea5cff27449f3f63e2d7bdbea3b">gdsl_stack_is_empty</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a stack is empty.  <a href="#g05718ea5cff27449f3f63e2d7bdbea3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#ga8464560e005bf2cb91fa12055359b95">gdsl_stack_get_top</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the top of a stack.  <a href="#ga8464560e005bf2cb91fa12055359b95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g09b1e39af6f153586bcd44be16678fd8">gdsl_stack_get_bottom</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the bottom of a stack.  <a href="#g09b1e39af6f153586bcd44be16678fd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gc1ae848edf02e7e2ce06ce0f0b84c249">gdsl_stack_set_name</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, const char *NEW_NAME)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of a stack.  <a href="#gc1ae848edf02e7e2ce06ce0f0b84c249"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gb913e793c095b977856a3367a58ea161">gdsl_stack_set_growing_factor</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a> G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the growing factor of a stack.  <a href="#gb913e793c095b977856a3367a58ea161"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gc3566b143b4e3129719840660c9824b3">gdsl_stack_insert</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, void *VALUE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an element in a stack (PUSH).  <a href="#gc3566b143b4e3129719840660c9824b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gab5fda5eded58afa96fe179937697940">gdsl_stack_remove</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an element from a stack (POP).  <a href="#gab5fda5eded58afa96fe179937697940"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gabe9364e7e4d4df0ec2c43a9c94f17bd">gdsl_stack_search</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#g200177a9a1ac3f2363e228b0e5faeda7">gdsl_compare_func_t</a> COMP_F, void *VALUE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a particular element in a stack.  <a href="#gabe9364e7e4d4df0ec2c43a9c94f17bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g025af567070bbc933a380c4efcf8a529">gdsl_stack_search_by_position</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a> POS)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for an element by its position in a stack.  <a href="#g025af567070bbc933a380c4efcf8a529"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g09c4e7d90846c987e009070395db9519">gdsl_stack_map_forward</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#g2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a> MAP_F, void *USER_DATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a stack from bottom to top.  <a href="#g09c4e7d90846c987e009070395db9519"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gaec1bfd42894b1d163a59f3a06194c93">gdsl_stack_map_backward</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#g2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a> MAP_F, void *USER_DATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a stack from top to bottom.  <a href="#gaec1bfd42894b1d163a59f3a06194c93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#g5862ed3924559830be65c7e6b364d217">gdsl_stack_write</a> (const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#gfc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a> WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write all the elements of a stack to a file.  <a href="#g5862ed3924559830be65c7e6b364d217"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gce0385f078efc764f4da7bf68b71942a">gdsl_stack_write_xml</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#gfc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a> WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the content of a stack to a file into XML.  <a href="#gce0385f078efc764f4da7bf68b71942a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gdsl__stack.html#gcdd3cfc7a7060ecc8278be39a7a79219">gdsl_stack_dump</a> (<a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> S, <a class="el" href="group__gdsl__types.html#gfc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a> WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump the internal structure of a stack to a file.  <a href="#gcdd3cfc7a7060ecc8278be39a7a79219"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ged560443d2612fcdb10a55a51687cbbb"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_t" ref="ged560443d2612fcdb10a55a51687cbbb" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct _gdsl_stack* <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
GDSL stack type. 
<p>
This type is voluntary opaque. Variables of this kind could'nt be directly used, but by the functions of this module. 
<p>
Definition at line <a class="el" href="gdsl__stack_8h-source.html#l00053">53</a> of file <a class="el" href="gdsl__stack_8h-source.html">gdsl_stack.h</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g226386196ca32ee4eae9441f9229a990"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_alloc" ref="g226386196ca32ee4eae9441f9229a990" args="(const char *NAME, gdsl_alloc_func_t ALLOC_F, gdsl_free_func_t FREE_F)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> gdsl_stack_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>NAME</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g32a9b4e8b9665183c2741d28a5ced64f">gdsl_alloc_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ALLOC_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g2c6b3f96b291b5b39d2799f93e350053">gdsl_free_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FREE_F</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new stack. 
<p>
Allocate a new stack data structure which name is set to a copy of NAME. The functions pointers ALLOC_F and FREE_F could be used to respectively, alloc and free elements in the stack. These pointers could be set to NULL to use the default ones:<ul>
<li>the default ALLOC_F simply returns its argument</li><li>the default FREE_F does nothing</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>nothing. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NAME</em>&nbsp;</td><td>The name of the new stack to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ALLOC_F</em>&nbsp;</td><td>Function to alloc element when inserting it in a stack </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FREE_F</em>&nbsp;</td><td>Function to free element when deleting it from a stack </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the newly allocated stack in case of success. <p>
NULL in case of insufficient memory. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gc115f451db17f6509048018bdef1ffe6">gdsl_stack_free()</a> <p>
<a class="el" href="group__gdsl__stack.html#g2ad434c6a6cd2e66033195a9cee5919f">gdsl_stack_flush()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc115f451db17f6509048018bdef1ffe6"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_free" ref="gc115f451db17f6509048018bdef1ffe6" args="(gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void gdsl_stack_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a stack. 
<p>
Deallocate all the elements of the stack S by calling S's FREE_F function passed to <a class="el" href="group__gdsl__stack.html#g226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc()</a>. The name of S is deallocated and S is deallocated itself too.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to destroy </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc()</a> <p>
<a class="el" href="group__gdsl__stack.html#g2ad434c6a6cd2e66033195a9cee5919f">gdsl_stack_flush()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g2ad434c6a6cd2e66033195a9cee5919f"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_flush" ref="g2ad434c6a6cd2e66033195a9cee5919f" args="(gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void gdsl_stack_flush           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flush a stack. 
<p>
Deallocate all the elements of the stack S by calling S's FREE_F function passed to <a class="el" href="group__gdsl__stack.html#g226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc()</a>. S is not deallocated itself and S's name is not modified.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to flush </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc()</a> <p>
<a class="el" href="group__gdsl__stack.html#gc115f451db17f6509048018bdef1ffe6">gdsl_stack_free()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gf8e7609d8785a3c5f458b996aa42baef"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_name" ref="gf8e7609d8785a3c5f458b996aa42baef" args="(const gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char* gdsl_stack_get_name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Getsthe name of a stack. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>Q must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>The returned string MUST NOT be freed. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to get the name from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the name of the stack S. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gc1ae848edf02e7e2ce06ce0f0b84c249">gdsl_stack_set_name()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g240a364616309e15eb374469af80a019"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_size" ref="g240a364616309e15eb374469af80a019" args="(const gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a> gdsl_stack_get_size           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the size of a stack. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to get the size from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of elements of the stack S (noted |S|). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g89fc03e3da09672b366c6e3f1dd3bb4c"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_growing_factor" ref="g89fc03e3da09672b366c6e3f1dd3bb4c" args="(const gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a> gdsl_stack_get_growing_factor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the growing factor of a stack. 
<p>
Get the growing factor of the stack S. This value is the amount of cells to reserve for next insertions. For example, if you set this value to 10, each time the number of elements of S reaches 10, then 10 new cells will be reserved for next 10 insertions. It is a way to save time for insertions. This value is 1 by default and can be modified with <a class="el" href="group__gdsl__stack.html#gb913e793c095b977856a3367a58ea161">gdsl_stack_set_growing_factor()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to get the growing factor from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the growing factor of the stack S. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gc3566b143b4e3129719840660c9824b3">gdsl_stack_insert()</a> <p>
<a class="el" href="group__gdsl__stack.html#gb913e793c095b977856a3367a58ea161">gdsl_stack_set_growing_factor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g05718ea5cff27449f3f63e2d7bdbea3b"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_is_empty" ref="g05718ea5cff27449f3f63e2d7bdbea3b" args="(const gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#gf6a258d8f3ee5206d682d799316314b1">bool</a> gdsl_stack_is_empty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if a stack is empty. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to check </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if the stack S is empty. <p>
FALSE if the stack S is not empty. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8464560e005bf2cb91fa12055359b95"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_top" ref="ga8464560e005bf2cb91fa12055359b95" args="(const gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_get_top           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the top of a stack. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to get the top from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the element contained at the top position of the stack S if S is not empty. The returned element is not removed from S. <p>
NULL if the stack S is empty. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g09b1e39af6f153586bcd44be16678fd8">gdsl_stack_get_bottom()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g09b1e39af6f153586bcd44be16678fd8"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_get_bottom" ref="g09b1e39af6f153586bcd44be16678fd8" args="(const gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_get_bottom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the bottom of a stack. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to get the bottom from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the element contained at the bottom position of the stack S if S is not empty. The returned element is not removed from S. <p>
NULL if the stack S is empty. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#ga8464560e005bf2cb91fa12055359b95">gdsl_stack_get_top()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc1ae848edf02e7e2ce06ce0f0b84c249"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_set_name" ref="gc1ae848edf02e7e2ce06ce0f0b84c249" args="(gdsl_stack_t S, const char *NEW_NAME)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a> gdsl_stack_set_name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>NEW_NAME</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the name of a stack. 
<p>
Change the previous name of the stack S to a copy of NEW_NAME.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to change the name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NEW_NAME</em>&nbsp;</td><td>The new name of S </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the modified stack in case of success. <p>
NULL in case of insufficient memory. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gf8e7609d8785a3c5f458b996aa42baef">gdsl_stack_get_name()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gb913e793c095b977856a3367a58ea161"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_set_growing_factor" ref="gb913e793c095b977856a3367a58ea161" args="(gdsl_stack_t S, ulong G)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void gdsl_stack_set_growing_factor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>G</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the growing factor of a stack. 
<p>
Set the growing factor of the stack S. This value is the amount of cells to reserve for next insertions. For example, if you set this value to 10, each time the number of elements of S reaches 10, then 10 new cells will be reserved for next 10 insertions. It is a way to save time for insertions. To know the actual value of the growing factor, use <a class="el" href="group__gdsl__stack.html#g89fc03e3da09672b366c6e3f1dd3bb4c">gdsl_stack_get_growing_factor()</a><p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to get the growing factor from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>The new growing factor of S. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the growing factor of the stack S. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gc3566b143b4e3129719840660c9824b3">gdsl_stack_insert()</a> <p>
<a class="el" href="group__gdsl__stack.html#g89fc03e3da09672b366c6e3f1dd3bb4c">gdsl_stack_get_growing_factor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc3566b143b4e3129719840660c9824b3"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_insert" ref="gc3566b143b4e3129719840660c9824b3" args="(gdsl_stack_t S, void *VALUE)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>VALUE</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an element in a stack (PUSH). 
<p>
Allocate a new element E by calling S's ALLOC_F function on VALUE. ALLOC_F is the function pointer passed to <a class="el" href="group__gdsl__stack.html#g226386196ca32ee4eae9441f9229a990">gdsl_stack_alloc()</a>. The new element E is the inserted at the top position of the stack S. If the number of elements in S reaches S's growing factor (G), then G new cells are reserved for future insertions into S to save time.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to insert in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VALUE</em>&nbsp;</td><td>The value used to make the new element to insert into S </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the inserted element E in case of success. <p>
NULL in case of insufficient memory. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gb913e793c095b977856a3367a58ea161">gdsl_stack_set_growing_factor()</a> <p>
<a class="el" href="group__gdsl__stack.html#g89fc03e3da09672b366c6e3f1dd3bb4c">gdsl_stack_get_growing_factor()</a> <p>
<a class="el" href="group__gdsl__stack.html#gab5fda5eded58afa96fe179937697940">gdsl_stack_remove()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gab5fda5eded58afa96fe179937697940"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_remove" ref="gab5fda5eded58afa96fe179937697940" args="(gdsl_stack_t S)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_remove           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>S</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove an element from a stack (POP). 
<p>
Remove the element at the top position of the stack S.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to remove the top from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the removed element in case of success. <p>
NULL in case of S is empty. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gc3566b143b4e3129719840660c9824b3">gdsl_stack_insert()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gabe9364e7e4d4df0ec2c43a9c94f17bd"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_search" ref="gabe9364e7e4d4df0ec2c43a9c94f17bd" args="(const gdsl_stack_t S, gdsl_compare_func_t COMP_F, void *VALUE)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_search           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g200177a9a1ac3f2363e228b0e5faeda7">gdsl_compare_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>COMP_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>VALUE</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search for a particular element in a stack. 
<p>
Search for the first element E equal to VALUE in the stack S, by using COMP_F to compare all S's element with.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; COMP_F != NULL </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to search the element in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>COMP_F</em>&nbsp;</td><td>The comparison function used to compare S's element with VALUE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VALUE</em>&nbsp;</td><td>The value to compare S's elements with </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the first founded element E in case of success. <p>
NULL if no element is found. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g025af567070bbc933a380c4efcf8a529">gdsl_stack_search_by_position()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g025af567070bbc933a380c4efcf8a529"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_search_by_position" ref="g025af567070bbc933a380c4efcf8a529" args="(const gdsl_stack_t S, ulong POS)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_search_by_position           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g9c34ac44da309b004570530c8cec8a0e">ulong</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>POS</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search for an element by its position in a stack. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( 1 ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; POS &gt; 0 &amp; POS &lt;= |S| </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to search the element in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>POS</em>&nbsp;</td><td>The position where is the element to search </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the element at the POS-th position in the stack S. <p>
NULL if POS &gt; |L| or POS &lt;= 0. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gabe9364e7e4d4df0ec2c43a9c94f17bd">gdsl_stack_search()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g09c4e7d90846c987e009070395db9519"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_map_forward" ref="g09c4e7d90846c987e009070395db9519" args="(const gdsl_stack_t S, gdsl_map_func_t MAP_F, void *USER_DATA)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_map_forward           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>MAP_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>USER_DATA</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Parse a stack from bottom to top. 
<p>
Parse all elements of the stack S from bottom to top. The MAP_F function is called on each S's element with USER_DATA argument. If MAP_F returns GDSL_MAP_STOP, then <a class="el" href="group__gdsl__stack.html#g09c4e7d90846c987e009070395db9519">gdsl_stack_map_forward()</a> stops and returns its last examinated element.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; MAP_F != NULL </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MAP_F</em>&nbsp;</td><td>The map function to apply on each S's element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USER_DATA</em>&nbsp;</td><td>User's datas passed to MAP_F Returns the first element for which MAP_F returns GDSL_MAP_STOP. Returns NULL when the parsing is done. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gaec1bfd42894b1d163a59f3a06194c93">gdsl_stack_map_backward()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gaec1bfd42894b1d163a59f3a06194c93"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_map_backward" ref="gaec1bfd42894b1d163a59f3a06194c93" args="(const gdsl_stack_t S, gdsl_map_func_t MAP_F, void *USER_DATA)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__types.html#g0e2b9d7fb5ca9e6d50100e5d9e4bcae7">gdsl_element_t</a> gdsl_stack_map_backward           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#g2500bfaaec5df890e72b43f448f13ee8">gdsl_map_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>MAP_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>USER_DATA</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Parse a stack from top to bottom. 
<p>
Parse all elements of the stack S from top to bottom. The MAP_F function is called on each S's element with USER_DATA argument. If MAP_F returns GDSL_MAP_STOP, then <a class="el" href="group__gdsl__stack.html#gaec1bfd42894b1d163a59f3a06194c93">gdsl_stack_map_backward()</a> stops and returns its last examinated element.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; MAP_F != NULL </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MAP_F</em>&nbsp;</td><td>The map function to apply on each S's element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USER_DATA</em>&nbsp;</td><td>User's datas passed to MAP_F </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the first element for which MAP_F returns GDSL_MAP_STOP. <p>
NULL when the parsing is done. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g09c4e7d90846c987e009070395db9519">gdsl_stack_map_forward()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g5862ed3924559830be65c7e6b364d217"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_write" ref="g5862ed3924559830be65c7e6b364d217" args="(const gdsl_stack_t S, gdsl_write_func_t WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void gdsl_stack_write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#gfc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>WRITE_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>OUTPUT_FILE</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>USER_DATA</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write all the elements of a stack to a file. 
<p>
Write the elements of the stack S to OUTPUT_FILE, using WRITE_F function. Additionnal USER_DATA argument could be passed to WRITE_F.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; OUTPUT_FILE != NULL &amp; WRITE_F != NULL </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WRITE_F</em>&nbsp;</td><td>The write function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUTPUT_FILE</em>&nbsp;</td><td>The file where to write S's elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USER_DATA</em>&nbsp;</td><td>User's datas passed to WRITE_F. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#gce0385f078efc764f4da7bf68b71942a">gdsl_stack_write_xml()</a> <p>
<a class="el" href="group__gdsl__stack.html#gcdd3cfc7a7060ecc8278be39a7a79219">gdsl_stack_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gce0385f078efc764f4da7bf68b71942a"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_write_xml" ref="gce0385f078efc764f4da7bf68b71942a" args="(gdsl_stack_t S, gdsl_write_func_t WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void gdsl_stack_write_xml           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#gfc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>WRITE_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>OUTPUT_FILE</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>USER_DATA</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the content of a stack to a file into XML. 
<p>
Write the elements of the stack S to OUTPUT_FILE, into XML language. If WRITE_F != NULL, then uses WRITE_F to write S's elements to OUTPUT_FILE. Additionnal USER_DATA argument could be passed to WRITE_F.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; OUTPUT_FILE != NULL </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WRITE_F</em>&nbsp;</td><td>The write function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUTPUT_FILE</em>&nbsp;</td><td>The file where to write S's elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USER_DATA</em>&nbsp;</td><td>User's datas passed to WRITE_F. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g5862ed3924559830be65c7e6b364d217">gdsl_stack_write()</a> <p>
<a class="el" href="group__gdsl__stack.html#gcdd3cfc7a7060ecc8278be39a7a79219">gdsl_stack_dump()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gcdd3cfc7a7060ecc8278be39a7a79219"></a><!-- doxytag: member="gdsl_stack.h::gdsl_stack_dump" ref="gcdd3cfc7a7060ecc8278be39a7a79219" args="(gdsl_stack_t S, gdsl_write_func_t WRITE_F, FILE *OUTPUT_FILE, void *USER_DATA)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void gdsl_stack_dump           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__gdsl__stack.html#ged560443d2612fcdb10a55a51687cbbb">gdsl_stack_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__gdsl__types.html#gfc7394b6c8e0a5bd92df75e24512dfd6">gdsl_write_func_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>WRITE_F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>OUTPUT_FILE</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>USER_DATA</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the internal structure of a stack to a file. 
<p>
Dump the structure of the stack S to OUTPUT_FILE. If WRITE_F != NULL, then uses WRITE_F to write S's elements to OUTPUT_FILE. Additionnal USER_DATA argument could be passed to WRITE_F.<p>
<dl compact><dt><b>Note:</b></dt><dd>Complexity: O( |S| ) </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>S must be a valid gdsl_stack_t &amp; OUTPUT_FILE != NULL </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>S</em>&nbsp;</td><td>The stack to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WRITE_F</em>&nbsp;</td><td>The write function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUTPUT_FILE</em>&nbsp;</td><td>The file where to write S's elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USER_DATA</em>&nbsp;</td><td>User's datas passed to WRITE_F. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__gdsl__stack.html#g5862ed3924559830be65c7e6b364d217">gdsl_stack_write()</a> <p>
<a class="el" href="group__gdsl__stack.html#gce0385f078efc764f4da7bf68b71942a">gdsl_stack_write_xml()</a> </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Dec 12 17:26:36 2006 for gdsl by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
