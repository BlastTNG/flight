#!/usr/bin/perl -w

%define = (
  M_PI => '3.14159265358979323846'
);

sub evaldefine {
  my $val = shift;
  $val = "1 + 2 + 1 + N_SLOW + N_FASTCHLIST" if $val eq "\\"; # FRAME_WORDS
  
  for $k (keys %define) {
    $val =~ s/sizeof\(unsigned short\)/4/g;
    $val =~ s/sizeof\(unsigned int\)/8/g;
    $val =~ s/\b$k\b/$define{$k}/g;
  }
  die $val if ($val =~ /[A-Z][A-Z]/);

  return eval($val);
}

open INPUT, "<tx_struct.h" or die "ERROR: Unable to open tx_struct.h";
open STDOUT, ">all.channel.list" or die "ERROR: Cannot write to all.channel.list";
print "# ALL CHANNEL LIST\n#   This file is automatically generated by all.channels based on the contents\n#   of tx_struct.h and tx_struct.c\n#\n#\n# HEADER DEFINITIONS FOLLOW:\n\n";

while (<INPUT>) {
  if (/#define ([^ ]*) (.*)/) {
    $define{$1} = evaldefine($2);
    print "# $1 is $define{$1}\n";
  }
}
print "#\n";

$FAST_OFFSET = $define{'FAST_OFFSET'};

print "# fast fields (N_FASTCHLIST): ", $N_FASTCHLIST_INIT + $DAS_CARDS * 1.5 * $DAS_CHS, "\n" if (defined $N_FASTCHLIST_INIT and defined $DAS_CARDS and defined $DAS_CHS);

print "# fast channel list offset (FAST_OFFSET): ", $FAST_OFFSET = $define{'FAST_OFFSET'}, "\n";

open INPUT, "<tx_struct.c" or die "ERROR: Unable to open tx_struct.c";

while (<INPUT>) {
  if (/#define (SPARE|CRYO|BIAS|(?:ACS|DAS|LOOP)[N0-9]+) +([0-9]*)/) {
    $node{$1} = $2;
    print "# Node mapping: $1 == $2\n";
  } elsif ($slowlist) {
    if (@record =
        /^[^\/\*]*{"(.*)" *, *'(.)' *, *(.*) *, *(.*) *, *(.*) *, *(.*) *, *'(.)' *}/) {
      @record = ($slowch, $slowind, @record);
      $record[4] = $node{$record[4]};
      if ($record[2] ne "") {
        $record[6] = evaldefine($record[6]);
        $record[7] = evaldefine($record[7]);
        printf " %2i %2i  %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @record;
        push @recs, [ @record ];
      }
      $slowind++;
    } elsif (/^[^\/\*{]*},/) {
      $slowch++;
      $slowind = 0;
    } elsif (/^[^\/\*{]*};/) {
      $slowlist = 0;
    }
  } elsif ($fastlist) {
    if (@record =
        /^[^\/\*]*{"(.*)" *, *'(.)' *, *(.*) *, *(.*) *, *(.*) *, *(.*) *, *'(.)' *}/) {
      @record = (-1, $fastind, @record);
      $record[4] = $node{$record[4]};
      if ($record[2] ne "" and $record[2] ne "ENDMARKER") {
        $record[6] = evaldefine($record[6]);
        $record[7] = evaldefine($record[7]);
        push @recs, [ @record ];
        (undef, @record) = @record;
        printf "  %3i   %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @record;
      }
      $fastind++ if ($record[1] ne "ENDMARKER");
    } elsif (/^[^\/\*{]*};/) {
      $fastlist = 0;
    }
  } else {
    if (/struct ChannelStruct SlowChList.*= {/) {
      $slowlist = 1;
      print "#\n#\n# SLOW CHANNEL LIST\n# indx ----- field name ---- r/w node adr -------- m -------  ------- b -------- type\n";
      $slowch  = 0;
      $slowind = 0;
    } elsif (/struct ChannelStruct FastChList.*= {/) {
      $fastlist = 1;
      print "#\n#\n# FAST CHANNEL LIST\n# indx ----- field name ---- r/w node adr -------- m -------  ------- b -------- type\n";
      $fastind = $FAST_OFFSET;
    } elsif (($dasm, $dasb) = /struct ChannelStruct channel = {"", 'r', 3, 0, *(.*) *, *(.*) *, 'u'};/) {
      @record = (-1, -1, "n?c?", 'r', -1, -1, $dasm, $dasb, 'u');
      push @recs, [ @record ];
      (undef, @record) = @record;
      printf "  %3i   %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @record;

      open STDOUT, ">all.channel.list.alpha" or die "ERROR: Cannot write to all.channel.list.alpha";
      print "# ALL CHANNEL LIST\n#   This file is automatically generated by all.channels based on the contents\n#   of tx_struct.h and tx_struct.c\n#\n#\n";
      print "# Node mapping: $_ == $node{$_}\n" for (sort {$node{$a} <=>
          $node{$b}} keys %node);
      print "#\n#\n# ALPHABETICAL LIST\n# indx ----- field name ---- r/w node adr -------- m -------  ------- b -------- type\n";
      @sorted = sort {$$a[2] cmp $$b[2]} @recs;
      for (@sorted) {
        if ($$_[0] == -1) {
          (undef, @record) = @$_;
          printf "  %3i   %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @record;
        } else {
          printf " %2i %2i  %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @$_;
        }
      }

      open STDOUT, ">all.channel.list.node" or die "ERROR: Cannot write to all.channel.list.node";
      print "# ALL CHANNEL LIST\n#   This file is automatically generated by all.channels based on the contents\n#   of tx_struct.h and tx_struct.c\n#\n#\n";
      print "# Node mapping: $_ == $node{$_}\n" for (sort {$node{$a} <=>
          $node{$b}} keys %node);
      print "#\n#\n# NODE/CHANNEL LIST\n# indx ----- field name ---- r/w node adr -------- m -------  ------- b -------- type\n";
      @sorted = sort {
        (($$a[3] eq 'w') ? 100 : 0) + $$a[4] * 100000 + $$a[5] <=>
        (($$b[3] eq 'w') ? 100 : 0) + $$b[4] * 100000 + $$b[5]
      } @recs;
      for (@sorted) {
        if ($$_[0] == -1) {
          (undef, @record) = @$_;
          printf "  %3i   %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @record;
        } else {
          printf " %2i %2i  %-20s  %1s   %2i  %2i  %18g  %18g  %s\n", @$_;
        }
      }
    }
  }
}
