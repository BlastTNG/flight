Index: python/auto_setup/series_array.py
===================================================================
--- python/auto_setup/series_array.py	(revision 1151)
+++ python/auto_setup/series_array.py	(working copy)
@@ -197,6 +197,27 @@
         rs.analysis = {'lock_x': self.bias[idx]}
         return rs
 
+    def sqtune_report(self):
+        """
+        Return description of results for runfile block.
+        """
+        def get(key):
+            return self.analysis[key].reshape(self.data_shape[-3:-1]).ravel()
+        data = [
+            {'label': 'Squid_vphi_p2p',
+             'data': get('y_span'),
+             'style': 'col', 'format': '%i', },
+            {'label': 'Squid_lockrange',
+             'data': get('right_idx') - get('left_idx'),
+             'style': 'col', 'format': '%i', },
+            {'label': 'Squid_lockslope',
+             'data': get('lock_slope'),
+             'style': 'col', 'format': '%.3f', },
+            {'label': 'Squid_lock_count',
+             'data': get('lock_count'),
+             'style': 'col', 'format': '%i', },
+            ]
+        return data
 
 class SARampSummary(servo.RampSummary):
     xlabel = 'SA BIAS'
Index: python/auto_setup/servo.py
===================================================================
--- python/auto_setup/servo.py	(revision 1151)
+++ python/auto_setup/servo.py	(working copy)
@@ -167,6 +167,19 @@
                                         n_points=scale,
                                         min_index=i_left, max_index=i_right)
         dx = zeros(y.shape[0])
+    
+    n_locks = []
+    for ok, yy, lidx in zip(oks,y, lock_idx):
+        if not ok:
+            n = 0
+        else:
+            # find all slopy regions
+            locks = [array([max(0,x[0]), min(len(yy)-1,x[1])])
+                     for x in get_curve_regions(yy, slopes=True, extremality=extremality)
+                     if x[0] != x[1]]
+            # count the regions that cross the lock point
+            n = sum([(min(yy[x])<yy[lidx] and max(yy[x])>yy[lidx]) for x in locks])
+        n_locks.append(n)
 
     return {'lock_idx': lock_idx,
             'lock_didx': dx,
@@ -175,6 +188,7 @@
             'slope': slope,
             'left_idx': i_left,
             'right_idx': i_right,
+            'lock_count': array(n_locks),
             'ok': array(oks)
             }
 
@@ -819,6 +833,10 @@
     print 'Expected: ', N/array(F)
     lp = get_lock_points(y, slope=array([1,1,1,-1]))
     print 'Lock-x: ', lp['lock_idx']
+    reg = []
+    for yy in y:
+        reg.append(get_curve_regions(yy, slopes=True))
+        print 'Crossings: ', reg[-1]
     print 'Plotting...'
     fp = biggles.Table(2,2)
     for i in range(4):
Index: python/auto_setup/sq1_servo.py
===================================================================
--- python/auto_setup/sq1_servo.py	(revision 1151)
+++ python/auto_setup/sq1_servo.py	(working copy)
@@ -281,6 +281,7 @@
         return self.analysis
 
     def reduce(self, slope=None, lock_amp=True):
+        self.reduce1()
         self._check_data()
         self._check_analysis(existence=True)
         
@@ -310,8 +311,8 @@
         an['lock_x'] += (d_fb * an['lock_didx']).astype('int')
         an['lock_slope'] /= d_fb
 
-        self.analysis = an
-        return an
+        self.analysis.update(an)
+        return self.analysis
 
     def select_biases(self, bias_idx=None, assoc=None, ic_factor=None):
         """
@@ -408,8 +409,29 @@
         idx = self.analysis['select_row_sel']
         rs.analysis = {'lock_x': self.bias[idx]}
         return rs
-        
 
+    def sqtune_report(self):
+        """
+        Return description of results for runfile block.
+        """
+        def get(key):
+            return self.analysis[key].reshape(self.data_shape[-3:-1]).transpose()
+        data = [
+            {'label': 'Col%i_squid_vphi_p2p',
+             'data': get('y_span'),
+             'style': 'col_row', 'format': '%i', },
+            {'label': 'Col%i_squid_lockrange',
+             'data': get('right_idx') - get('left_idx'),
+             'style': 'col_row', 'format': '%i', },
+            {'label': 'Col%i_squid_lockslope',
+             'data': get('lock_slope'),
+             'style': 'col_row', 'format': '%.3f', },
+            {'label': 'Col%i_squid_lock_count',
+             'data': get('lock_count'),
+             'style': 'col_row', 'format': '%i', },
+            ]
+        return data
+
 class SQ1ServoSA(SQ1Servo):
     stage_name = 'SQ1ServoSA'
     xlabel = 'SQ1 FB / 1000'
Index: python/auto_setup/sq1_ramp.py
===================================================================
--- python/auto_setup/sq1_ramp.py	(revision 1151)
+++ python/auto_setup/sq1_ramp.py	(working copy)
@@ -202,8 +202,8 @@
         Finds curve amplitudes, locking levels, locking points.
         Creates analysis elements
                {min,max}_y
-               {left,,right}_idx
-               lock_{idx,y}
+               {left,right}_idx
+               lock_{idx,y,count}
         """
         self._check_data()
         # Analyze every single stupid rampc curve
@@ -233,7 +233,7 @@
             # Find largest y-separation between local extrema
             lims = []
             for T_set, yy in zip(Tex, y):
-                z = sorted([(yy[x], x) for x in T_set])
+                z = [(yy[x], x) for x in T_set]
                 dz = [a[0] - b[0] for a, b in zip(z[1:],z[:-1])]
                 idx = argmax(dz)
                 lims.append((z[idx][1], z[idx+1][1]))
@@ -277,20 +277,27 @@
         #left = result['left_idx'] - x_offset
         targets = result['lock_y']
         for word, sgn in [('up', 1), ('dn',-1)]:
-            ok, idx, sl = [zeros(y.shape[0], x) for x in ['bool','int','float']]
+            ok, idx, sl, nl = [zeros(y.shape[0], x) for x in ['bool','int','float','int']]
             for i, (yy, t) in enumerate(zip(y, targets)):
                 rg = (len(yy)/4, len(yy))
                 o, d, s = lock_stats(yy, target=t, slope_points=scale/2, slope=sgn,
                                      range=rg)
-                if d > len(yy): d = len(yy)
+                if d > len(yy): d = len(yy)-1
                 if d < 0: d = 0
-                ok[i], idx[i], sl[i] = o, d, s
+                # find all slopy regions
+                locks = [array([max(0,x[0]), min(len(yy)-1,x[1])])
+                         for x in servo.get_curve_regions(yy, slope=sgn)
+                         if x[0] != x[1]]
+                # count the regions that cross the lock point
+                n = sum([(min(yy[x])<yy[d] and max(yy[x])>yy[d]) for x in locks])
+                ok[i], idx[i], sl[i], nl[i] = o, d, s, n
             idx[idx<abs_lims[0]] = abs_lims[0]
             idx[idx>abs_lims[1]] = abs_lims[1]
             result['lock_%s_idx'%word] = idx + x_offset
             result['lock_%s_slope'%word] = sl / self.d_fb
             result['lock_%s_ok'%word] = ok.astype('int')
             result['lock_%s_x'%word] = self.fb[result['lock_%s_idx'%word]]
+            result['lock_%s_count'%word] = nl
         return result
 
     def reduce(self):
@@ -352,6 +359,12 @@
             {'label': 'Col%i_squid_lockslope_up',
              'data': get('lock_up_slope'),
              'style': 'col_row', 'format': '%.3f', },
+            {'label': 'Col%i_squid_lock_count_dn',
+             'data': get('lock_dn_count'),
+             'style': 'col_row', 'format': '%i', },
+            {'label': 'Col%i_squid_lock_count_up',
+             'data': get('lock_up_count'),
+             'style': 'col_row', 'format': '%i', },
 #            {'label': 'Col%i_squid_multilock',
 #             'data': get(''),
 #             'style': 'col_row', 'format': '%i', },
Index: python/auto_setup/sq2_servo.py
===================================================================
--- python/auto_setup/sq2_servo.py	(revision 1151)
+++ python/auto_setup/sq2_servo.py	(working copy)
@@ -211,8 +211,8 @@
         an['lock_x'] += (d_fb * an['lock_didx']).astype('int')
         an['lock_slope'] /= d_fb
 
-        self.analysis = an
-        return an
+        self.analysis.update(an)
+        return self.analysis
 
     def select_biases(self, bias_idx=None, assoc=None, ic_factor=None):
         """
@@ -249,6 +249,27 @@
         rs.analysis = {'lock_x': self.bias[idx]}
         return rs
 
+    def sqtune_report(self):
+        """
+        Return description of results for runfile block.
+        """
+        def get(key):
+            return self.analysis[key].ravel()
+        data = [
+            {'label': 'Squid_vphi_p2p',
+             'data': get('y_span'),
+             'style': 'col', 'format': '%i', },
+            {'label': 'Squid_lockrange',
+             'data': get('right_idx') - get('left_idx'),
+             'style': 'col', 'format': '%i', },
+            {'label': 'Squid_lockslope',
+             'data': get('lock_slope'),
+             'style': 'col', 'format': '%.3f', },
+            {'label': 'Squid_lock_count',
+             'data': get('lock_count'),
+             'style': 'col', 'format': '%i', },
+            ]
+        return data
 
 class SQ2ServoSummary(servo.RampSummary):
     xlabel = 'SQ2 BIAS'
Index: python/auto_setup/main.py
===================================================================
--- python/auto_setup/main.py	(revision 1151)
+++ python/auto_setup/main.py	(working copy)
@@ -195,7 +195,7 @@
         plot_out = sa.plot()
         tuning.register_plots(*plot_out['plot_files'])
 
-    return {"status": 0, "column_adc_offset": target}
+    return {"status": 0, "column_adc_offset": target, 'ramp': sa}
 
 
 def do_sq2_servo(tuning, rc, rc_indices, tune_data, write_default=False):
@@ -271,7 +271,7 @@
     tuning.set_exp_param('sq2_fb_set', fb_set.transpose().ravel())
 
     tuning.write_config()
-    return {"status": 0}
+    return {"status": 0, "servo": sq}
 
 
 def prepare_sq1_servo(tuning):
@@ -362,7 +362,7 @@
     tuning.set_exp_param('sq2_fb_set', fb_set.transpose().ravel())
 
     tuning.write_config()
-    return 0
+    return {"status": 0, "servo": sq}
 
 
 def do_sq1_ramp(tuning, rcs, tune_data, init=True, ramp_check=False):
@@ -604,17 +604,20 @@
             sa_dict = do_sa_ramp(tuning, c, rc_indices,
                                  ramp_sa_bias=ramp_sa_bias,
                                  write_default=write_default_bias)
+            tuning.write_sqtune(sq_data=sa_dict['ramp'], stage='sa_ramp')
         if 'sq2_servo' in stages:
             s2_dict = do_sq2_servo(tuning, c, rc_indices, tune_data,
                                    write_default=write_default_bias)
+            tuning.write_sqtune(sq_data=s2_dict['servo'], stage='sq2_servo')
             if (s2_dict["status"] != 0):
                 return s2_dict["status"]
         if 'sq1_servo' in stages:
             prepare_sq1_servo(tuning)
-            e = do_sq1_servo(tuning, c, rc_indices, tune_data,
-                             write_default=write_default_bias)
-            if (e != 0):
-                return e
+            s1_dict = do_sq1_servo(tuning, c, rc_indices, tune_data,
+                                   write_default=write_default_bias)
+            tuning.write_sqtune(sq_data=s1_dict['servo'], stage='sq1_servo')
+            if (s1_dict["status"] != 0):
+                return s1_dict["status"]
 
     if 'rs_servo' in stages:
         rs = mux11d.do_rs_servo(tuning, rcs, tune_data)
@@ -625,12 +628,12 @@
     if 'sq1_ramp' in stages:
         # sq1 ramp
         sq1 = do_sq1_ramp(tuning, rcs, tune_data)
-        tuning.write_sqtune(sq1_ramp=sq1)
+        tuning.write_sqtune(sq_data=sq1, stage='sq1_ramp')
 
     if 'sq1_ramp_check' in stages:
         # sq1 ramp check
         sq1 = do_sq1_ramp(tuning, rcs, tune_data, ramp_check=True)
-        tuning.write_sqtune(sq1_ramp=sq1)
+        tuning.write_sqtune(sq_data=sq1, stage='sq1_ramp_check')
 
     if 'sq1_ramp_tes' in stages:
         # open-loop ramping of the TES bias
Index: python/auto_setup/util/plotter.py
===================================================================
--- python/auto_setup/util/plotter.py	(revision 1151)
+++ python/auto_setup/util/plotter.py	(working copy)
@@ -1,4 +1,4 @@
-import os, shutil
+import os, shutil, sys
 import distutils.version as dvs
 import biggles
 
@@ -412,7 +412,7 @@
     from svglib.svglib import svg2rlg
     from reportlab.graphics import renderPDF
 except:
-    print 'Failed to load PDF collation libraries.'
+    print >> sys.stderr, 'Failed to load PDF collation libraries.'
 
 
 class pdfCollator:
Index: python/auto_setup/util/tuning.py
===================================================================
--- python/auto_setup/util/tuning.py	(revision 1151)
+++ python/auto_setup/util/tuning.py	(working copy)
@@ -184,31 +184,48 @@
             if (flush):
                 self.log.flush()
 
-    def write_sqtune(self, filename=None, sq1_ramp=None, link=False):
+    def write_sqtune(self, filename=None, sq_data=None, link=False, stage=None,
+                     append=True):
         def compose_col_row(label, data, format='%f'):
             s = ''
             for i, d in enumerate(data):
                 s += '<%s> ' % (label % i)
                 s += ' '.join([format % r for r in d]) + '\n'
             return s
+        def compose_col(label, data, format='%f'):
+            s = '<%s> ' % (label)
+            s += ' '.join([format %r for r in data]) + '\n'
+            return s
 
         if filename == None:
             filename = self.sqtune_file
-        done = sq1_ramp != None
-        f = open(filename, 'w')
-        f.write("<SQUID>\n")
+        done = sq_data != None
+        f = open(filename, 'a' if append else 'w')
+        if stage in ['sq1_ramp','sq1_ramp_check']:
+            block = 'SQUID'
+        elif stage == 'sa_ramp':
+            block = 'SA_RAMP'
+        elif stage == 'sq2_servo':
+            block = 'SQ2_SERVO'
+        elif stage == 'sq1_servo':
+            block = 'SQ1_SERVO'
+        else: block = 'INIT'
+        f.write("<%s>\n" % block)
         f.write("<SQ_tuning_completed> %i\n" % int(done))
         f.write("<SQ_tuning_date> %s\n" % self.date)
         f.write("<SQ_tuning_dir> %s\n" % self.name)
-        if sq1_ramp != None:
-            for item in sq1_ramp.sqtune_report():
+        if sq_data != None:
+            for item in sq_data.sqtune_report():
                 s = item['style']
                 if s == 'col_row':
                     f.write(compose_col_row(item['label'], item['data'],
                                             format=item['format']))
+                elif s == 'col':
+                    f.write(compose_col(item['label'], item['data'],
+                                       format=item['format']))
                 else:
                     raise RuntimeError, 'unknown item style "%s"' % s
-        f.write("</SQUID>\n")
+        f.write("</%s>\n" % block)
         f.close()
         
         #this isn't updated if the user specified a data_dir when initialising
Index: script/plot_tuning
===================================================================
--- script/plot_tuning	(revision 1151)
+++ script/plot_tuning	(working copy)
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python
 
 import os
 import auto_setup as ast
