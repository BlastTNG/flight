#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include "tes.h"

#define LUT_DIR "/data/etc/spider/"
#define ETC_DIR "../spider_etc/"

/* gains and offsets for statistics */
#define MEAN_GAIN        (1./log(1.07))
#define MEAN_OFFSET      5000
#define SIGMA_GAIN       (1./log(1.03))
#define SIGMA_OFFSET     1000
#define NOISE_GAIN       (1./log(1.03))
#define NOISE_OFFSET     200

#define RESCALE_LOG(x,g,o) ((g) * log( (1. + ((x)<(o) ? (o) : (x))) / (1. + (o)) ))
#define LOOKUP_LOG(x,g,o)  ((1. + (o)) * exp((x) / (g)) - 1.)

char **names;
char **upnames;

char *GetArrayFieldName(int i_field, int upper) {
  if (upper == 0) return names[i_field];
  else return upnames[i_field];
}

char *GetArrayFieldLut(int i_field) {
  char *name = GetArrayFieldName(i_field, 0);
  switch (name[0]) {
  case 'm':
    return "mce_mean.lut";
  case 's':
    return "mce_sigma.lut";
  case 'n':
    return "mce_noise.lut";
  default:
    return "";
  }
}

int main() {
  int i, j;
  int type, tel, row, col;
  char types[N_STAT_TYPES][10] = {"mean", "sigma", "noise", "bstep"};
  FILE *fid;
  char fname[50];
  
  names = (char **) malloc(NUM_ARRAY_STAT * sizeof(char *));
  upnames = (char **) malloc(NUM_ARRAY_STAT * sizeof(char *));
  for (i=0; i < NUM_ARRAY_STAT; i++) {
    names[i] = (char *) malloc(21*sizeof(char));
    upnames[i] = (char *) malloc(21*sizeof(char));
  }
  i=0;
  for (tel = 0; tel < NUM_MCE; tel++) {
    for (type = 0; type < N_STAT_TYPES; type++) {
      for (row = 0; row<NUM_ROW; row++) {
	for (col = 0; col<NUM_COL; col++) {
	  sprintf(names[i], "%s_x%1dr%02dc%02d", types[type], tel+1, row, col);
	  for (j=0; j<strlen(names[i]); j++)
	    upnames[i][j] = toupper(names[i][j]);
	  i++;
	}
      }
    }
  }
  
  strcpy(fname, ETC_DIR "format.bolo_stats");
  fid = fopen(fname,"w");
  fprintf(fid, "# This file is automatically generated.\n"
	  "# To regenerate this file, build mpc on a MCC.\n");
  fprintf(fid, "bolo_stats_mplex_0 BIT bolo_stats_mplex 0 8\n"
	  "bolo_stats_mplex_1 BIT bolo_stats_mplex 8 8\n");
  
  i = 0;
  for (tel = 0; tel < NUM_MCE; tel++) {
    for (type = 0; type < N_STAT_TYPES; type++) {
      for (row = 0; row < NUM_ROW; row++) {
	for (col = 0; col < NUM_COL; col += 2) {
	  if (type == bs_step) {
	    fprintf(fid, "%s MPLEX bolo_stats_mplex_0 bolo_stats_index %d %d\n"
		    "%s LINCOM 1 %s %d %d \n"
		    "%s MPLEX bolo_stats_mplex_1 bolo_stats_index %d %d\n"
		    "%s LINCOM 1 %s %d %d\n",
		    GetArrayFieldName(i,0), i, NUM_ARRAY_STAT,
		    GetArrayFieldName(i,1), GetArrayFieldName(i,0),
		    500000/256, -333333,
		    GetArrayFieldName(i+1,0), i, NUM_ARRAY_STAT,
		    GetArrayFieldName(i+1,1), GetArrayFieldName(i+1,0),
		    500000/256, -333333
		    );
	  } else {
	    fprintf(fid,"%s MPLEX bolo_stats_mplex_0 bolo_stats_index %d %d\n"
		    "%s LINTERP %s %s%s\n"
		    "%s MPLEX bolo_stats_mplex_1 bolo_stats_index %d %d\n"
		    "%s LINTERP %s %s%s\n",
		    GetArrayFieldName(i,0), i, NUM_ARRAY_STAT,
		    GetArrayFieldName(i,1), GetArrayFieldName(i,0),
		    LUT_DIR, GetArrayFieldLut(i),
		    GetArrayFieldName(i+1,0), i, NUM_ARRAY_STAT,
		    GetArrayFieldName(i+1,1), GetArrayFieldName(i+1,0),
		    LUT_DIR, GetArrayFieldLut(i+1));
	  }
	  i += 2;
	}
      }
    }
  }
  fclose(fid);

  for (type = 0; type < N_STAT_TYPES; type++) {
    if (type == bs_step) continue;
    sprintf(fname,ETC_DIR "mce_%s.lut",types[type]);
    fid = fopen(fname,"w");
    for (i = 0; i < 256; i++) {
      switch (type) {
        case bs_mean:
	  fprintf(fid, "%3i %16.3f\n", i, ((i>128)-(i<128)) * LOOKUP_LOG( fabs(i-128),MEAN_GAIN,MEAN_OFFSET));
	  break;
        case bs_sigma:
	  fprintf(fid, "%3i %16.3f\n", i, LOOKUP_LOG(i,SIGMA_GAIN,SIGMA_OFFSET));
	  break;
        case bs_noise:
	  fprintf(fid, "%3i %16.3f\n", i, LOOKUP_LOG(i,NOISE_GAIN,NOISE_OFFSET));
	  break;
        default:
	  break;
      }
    }
    fclose(fid);
  }
  
  for (i=0; i<NUM_ARRAY_STAT; i++) {
    free(names[i]);
    free(upnames[i]);
  }
  free(names);
  free(upnames);
  
  return 0;
}
