#!/usr/bin/env python

import scipy.signal as _sig
import numpy as _np
import argparse, os.path, sys

def _box_filt (x,window=8,drop_ends=True):
    ''' Filters the NumPy array x with a boxcar filter of length window along the trailing axis.'''
    boxshape = _np.ones(len(x.shape),dtype=_np.int)
    boxshape[-1] = window
    box = _np.ones(boxshape)/window
    # perform the convolution...
    flt =  _sig.convolve(x,box,mode='same')
    # ... but the last window samples on each side are crap
    if drop_ends:
        # set the estimate to be level there.
        flt[...,:window] = _np.atleast_3d(flt[...,window])
        flt[...,-window:] = _np.atleast_3d(flt[...,-window])
    return flt

def _deriv(x,y):
    ''' Returns the simple derivative dy/dx at x values xv'''
    dydx = _np.diff(y,axis=-1)/_np.diff(x,axis=-1)
    xv = (x[...,:-1]+x[...,1:])/2.0
    return (xv,dydx)

def _set_bins(bias,bias_bin=50):
    '''Set up convenience structure for binning data in bias'''
    bins = {}
    bins['edges'] = _np.arange(0,max(bias)/bias_bin+2)*bias_bin
    bins['ctrs'] = (bins['edges'][1:]+bins['edges'][:-1])/2.0
    bins['N'] = len(bins['ctrs'])
    return bins
        
def nTrans(iv,bins=None,window=0):
    '''Count number of detectors on transition in each column, as a function of bias.
    We demand that a channel on-transition have a negative derivative over the entire bin.'''
    if not bins:
        bins = _set_bins(iv.Bbias)
    # Take a derivative of the smoothed load curve
    if window>0:
        (xB,dFBdB) = _deriv(iv.Bbias,_box_filt(iv.Bfb,window=window))        
    else:
        (xB,dFBdB) = _deriv(iv.Bbias,iv.Bfb)
    # check if we appear to be on transition at each sample
    onTrans = dFBdB<0
    # establish bins in bias
    bin_idx = _np.digitize(xB,bins['edges'])-1
    # preallocate for output
    dSh = dFBdB.shape
    nT = _np.zeros((dSh[1],bins['N']))
    # for each bin ...
    for bb in range(0,bins['N']):
        # ... multiply for each pixel to check if we're on transition throughout the bin
        # ... and sum over rows to get column counts
        cok = bin_idx==bb # _np.prod does weird things on empty arrays
        if _np.any(cok):
            nT[:,bb] = _np.sum(_np.prod(onTrans[...,bin_idx==bb],axis=-1),axis=0)
    return nT

def fomfunc(x,xmin,xmax,half_degree=1):
    '''Returns a FOM that is zero outside [xmin,xmax] and peaks at 1 at the center'''
    y = (x - (xmax+xmin)/2.0) / ((xmax-xmin)/2.0) # transformed variable
    fom = 1-y**(2*half_degree)
    fom[fom<0] = 0
    fom[_np.isnan(fom)] = 0
    return fom

def goodR(iv,bins=None,window=0,rfrac =[0.02,0.9]):
    '''which detectors have apparent resistance in range rfrac of Rn?
    Note that rfrac is actually slope ratios, not resistances.'''
    if not bins:
        bins = _set_bins(iv.Bbias)
    # Take a derivative of the smoothed load curve
    if window>0:
        (xB,dFBdB) = _deriv(iv.Bbias,_box_filt(iv.Bfb,window=window))        
    else:
        (xB,dFBdB) = _deriv(iv.Bbias,iv.Bfb)
    # establish bins in bias
    bin_idx = _np.digitize(xB,bins['edges'])-1
    # preallocate for binned slopes
    dSh = dFBdB.shape
    slp = _np.zeros((dSh[0],dSh[1],bins['N']))
    # for each bin ...
    for bb in range(0,bins['N']):
        # ... find the average slope in that bin
        cok = bin_idx==bb # _np.prod does weird things on empty arrays
        if _np.any(cok):
            slp[...,bb] = _np.mean(dFBdB[...,bin_idx==bb],axis=-1)
    # Slope corresponding to Rn/Rsh
    idxN = _np.digitize([iv.biasN()],bins['edges'])-1
    slpN = slp[:,:,idxN-1] # Hack by 1 to avoid numerical edge issues
    slpN[slpN<0]=1e-10
    # inverse slopes are like resistances
    # Slope range: r = R/Rsh = (1/slp - 1) ~ 1/slp
    rMin = -rfrac[0]/slpN
    rCtr = -_np.mean(rfrac)/slpN
    rMax = -rfrac[1]/slpN
    fom = fomfunc(1/slp,rMin,rMax)
    # sum up per column
    nR = _np.sum(fom,axis=0)
    return nR

def choose_biases(iv,window=0,bias_bin=50,rfrac = [0.2,0.8],Nthresh=2,
                  do_R=True, do_Trans=True, darks=False):
    ''' Combine a set of figures of merit to choose biases for each column'''
    # Establish BINS IN BIAS for all figures of merit
    bins = _set_bins(iv.Bbias,bias_bin=bias_bin)
    # Build up a FIGURE OF MERIT (FoM) for bias in each column
    fomset = []
    if do_R:
        # FoM1: number of detectors with negative slope
        fomset.append(nTrans(iv,bins,window=window))
    if do_Trans:
        # FoM2: number of detectors with resistances in range
        fomset.append(goodR(iv,bins,window=window,rfrac=rfrac))
    # COMBINED FoM
    Nfom = len(fomset)
    if Nfom==0:
        print 'No figures of merit selected!'
        return None
    fom = _np.prod(fomset,axis=0)**(1./Nfom) # "Geometric mean"...
    # CHOOSE BIASES
    idx = _np.argmax(fom,axis=-1)
    bias_set = bins['ctrs'][idx]
    # final tweaking: recognize weird values?
    tile = _np.arange(0,16,dtype=int)/4+1
    for col in range(0,len(idx)):
        fom_best = fom[col,idx[col]]
        if fom_best<Nthresh:
            bias_set[col] = _np.median(bias_set[tile==tile[col]])
    # RETURN RESULTS
    return _np.floor(bias_set)

class _miniIVcurve:
    '''Encapsulates the bare basics of an IV curve'''

    def __init__(self,ivname):
        from mce_data import MCEFile
        import numpy as _np
        self.Bfb = MCEFile(ivname).Read(row_col=True).data
        self.Bbias = _np.loadtxt(ivname+'.bias',comments='<').squeeze()
        # put in ascending order to simplify computations later
        if self.Bbias[-1]<self.Bbias[0]:
            # reverse the data into ascending order
            self.Bbias = self.Bbias[::-1]
            self.Bfb = self.Bfb[...,::-1]

    def isAl(self,thresh=10000):
        """Declare this to be an Al load curve if the applied bias exceeds some threshold"""
        return (self.Bbias.max() > thresh)

    def biasN(self,thresh=8000):
        """Return the bias which MAY correspond to Rn/Rsh"""
        if self.Bbias.max()<=thresh:
            # count back from the end slightly
            return self.Bbias.max()
        else:
            # get close to the threshold
            return self.Bbias[_np.argmin(_np.abs(self.Bbias-thresh))]

    
def main():
    p = argparse.ArgumentParser()
    p.add_argument('iv',default=None,type=str,
                   help='IV curve to work from (relative to . or /data/mce/ivcurves)')
    p.add_argument('--window',default=0,type=int,
                   help='Width of boxcar filter (samples) to smooth load curve')
    p.add_argument('--bin',default=50,type=int,
                   help='Width of bins in TES bias at which to compute figures of merit')
    p.add_argument('--rmin',default=0.1,type=float,
                   help='Approx. minimum R/Rn to accept a load curve')
    p.add_argument('--rmax',default=0.9,type=float,
                   help='Approx. maximum R/Rn at which to accept a load curve')
    p.add_argument('--Nmin',default=2,type=int,
                   help='Approx. minimum number of TESs required for tuning figure-of-merit')
    p.add_argument('--verbose',default=False,type=bool,
                   help='Should I print intermediate messages?')
    p.add_argument('--darks',default=False,type=bool,
                   help='Should I bias for the dark detectors?')
    p.add_argument('--ref',default=[],type=int,nargs=16,
                   help='List of reference biases from a previous load curve')
    p.add_argument('--kick-volts',type=float,default=None)
    p.add_argument('--kick-time',type=float,default=None)
    p.add_argument('--kick-wait',type=float,default=None)
    p.add_argument('--step-wait',type=float,default=None)
    args = p.parse_args()

    # Load the IV curve
    if os.path.isfile(args.iv):
        ivname = args.iv
    elif os.path.isfile(os.path.join('/data/mce/ivcurves',args.iv)):
        ivname = os.path.join('/data/mce/ivcurves',args.iv)
    else:
        sys.exit('Tuning directory not found')
    if args.verbose:
        print 'Using IV curve %s'%(os.path.abspath(ivname))
    try:
        iv = _miniIVcurve(ivname)
    except Exception:
        sys.exit('Failed to load IV curve')
    bias=choose_biases(iv,window=args.window,bias_bin=args.bin,
                       rfrac=[args.rmin,args.rmax],Nthresh=args.Nmin,darks=args.darks)
    print ''.join(['%d '%b for b in bias])


if __name__ == '__main__':
    main()
