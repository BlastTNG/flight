#!/usr/bin/env python

import scipy.signal as _sig
import numpy as _np
import argparse, os.path, sys

def _box_filt (x,window=8,drop_ends=True):
    ''' Filters the NumPy array x with a boxcar filter of length window along the trailing axis.'''
    boxshape = _np.ones(len(x.shape),dtype=_np.int)
    boxshape[-1] = window
    box = _np.ones(boxshape)/window
    # perform the convolution...
    flt =  _sig.convolve(x,box,mode='same')
    # ... but the last window samples on each side are crap
    if drop_ends:
        # set the estimate to be level there.
        flt[...,:window] = _np.atleast_3d(flt[...,window])
        flt[...,-window:] = _np.atleast_3d(flt[...,-window])
    return flt

def _deriv(x,y):
    ''' Returns the simple derivative dy/dx at x values xv'''
    dydx = _np.diff(y,axis=-1)/_np.diff(x,axis=-1)
    xv = (x[...,:-1]+x[...,1:])/2.0
    return (xv,dydx)

def _set_bins(bias,bias_bin=50):
    '''Set up convenience structure for binning data in bias'''
    bins = {}
    bins['edges'] = _np.arange(0,max(bias)/bias_bin+2)*bias_bin
    bins['ctrs'] = (bins['edges'][1:]+bins['edges'][:-1])/2.0
    bins['N'] = len(bins['ctrs'])
    return bins
        
def nTrans(iv,bins=None,window=0):
    '''Count number of detectors on transition in each column, as a function of bias.
    We demand that a channel on-transition have a negative derivative over the entire bin.'''
    if not bins:
        bins = _set_bins(iv.Bbias)
    # Take a derivative of the smoothed load curve
    if window>0:
        (xB,dFBdB) = _deriv(iv.Bbias,_box_filt(iv.Bfb,window=window))        
    else:
        (xB,dFBdB) = _deriv(iv.Bbias,iv.Bfb)
    # check if we appear to be on transition at each sample
    onTrans = dFBdB<0
    # establish bins in bias
    bin_idx = _np.digitize(xB,bins['edges'])-1
    # preallocate for output
    dSh = dFBdB.shape
    nT = _np.zeros((dSh[1],bins['N']))
    # for each bin ...
    for bb in range(0,bins['N']):
        # ... multiply for each pixel to check if we're on transition throughout the bin
        # ... and sum over rows to get column counts
        cok = bin_idx==bb # _np.prod does weird things on empty arrays
        if _np.any(cok):
            nT[:,bb] = _np.sum(_np.prod(onTrans[...,bin_idx==bb],axis=-1),axis=0)
    return nT

def goodR(iv,bins=None,window=0,rfrac =[0.1,0.9]):
    '''which detectors have apparent resistance in range rfrac of Rn?'''
    if not bins:
        bins = _set_bins(iv.Bbias)
    # Take a derivative of the smoothed load curve
    if window>0:
        (xB,dFBdB) = _deriv(iv.Bbias,_box_filt(iv.Bfb,window=window))        
    else:
        (xB,dFBdB) = _deriv(iv.Bbias,iv.Bfb)
    # establish bins in bias
    bin_idx = _np.digitize(xB,bins['edges'])-1
    # preallocate for binned slopes
    dSh = dFBdB.shape
    slp = _np.zeros((dSh[0],dSh[1],bins['N']))
    # for each bin ...
    for bb in range(0,bins['N']):
        # ... find the average slope in that bin
        cok = bin_idx==bb # _np.prod does weird things on empty arrays
        if _np.any(cok):
            slp[...,bb] = _np.mean(dFBdB[...,bin_idx==bb],axis=-1)
    # Slope corresponding to Rn/Rsh
    slpN = slp[:,:,-2]
    # Slope range: r = R/Rsh = (1/slp - 1) ~ 1/slp
    slpMin = -slpN/rfrac[0]
    slpMax = -slpN/rfrac[1]
    # did we nail it?
    rOk = _np.logical_and(slp>_np.expand_dims(slpMin,axis=2),slp<_np.expand_dims(slpMax,axis=2))
    # sum it up per column
    nR = _np.sum(rOk,axis=0)
    return nR

def choose_biases(iv,window=0,bias_bin=50,rfrac = [0.1,0.9],Nthresh=2,
                  do_R=True, do_Trans=True):
    ''' Combine a set of figures of merit to choose biases for each column'''
    # Establish BINS IN BIAS for all figures of merit
    bins = _set_bins(iv.Bbias,bias_bin=bias_bin)
    # Build up a FIGURE OF MERIT (FoM) for bias in each column
    fomset = []
    if do_R:
        # FoM1: number of detectors with negative slope
        fomset.append(nTrans(iv,bins,window=window))
    if do_Trans:
        # FoM2: number of detectors with resistances in range
        fomset.append(goodR(iv,bins,window=window,rfrac=rfrac))
    # COMBINED FoM
    Nfom = len(fomset)
    if Nfom==0:
        print 'No figures of merit selected!'
        return None
    fom = _np.prod(fomset,axis=0)**(1./Nfom) # "Geometric mean"...
    # CHOOSE BIASES
    idx = _np.argmax(fom,axis=-1)
    bias_set = bins['ctrs'][idx]
    # final tweaking: recognize weird values?
    tile = _np.arange(0,16,dtype=int)/4+1
    for col in range(0,len(idx)):
        fom_best = fom[col,idx[col]]
        if fom_best<Nthresh:
            bias_set[col] = _np.median(bias_set[tile==tile[col]])
    # RETURN RESULTS
    return _np.floor(bias_set)

class _miniIVcurve:
    '''Encapsulates the bare basics of an IV curve'''

    def __init__(self,ivname):
        from mce_data import MCEFile
        import numpy as _np
        self.Bfb = MCEFile(ivname).Read(row_col=True).data
        self.Bbias = _np.loadtxt(ivname+'.bias',comments='<').squeeze()

    
def main():
    p = argparse.ArgumentParser()
    p.add_argument('iv',default=None,type=str,
                   help='IV curve to work from (relative to ., $MAS_DATA, or /data/mce/ivcurves)')
    p.add_argument('--window',default=0,type=int,
                   help='Width of boxcar filter (samples) to smooth load curve')
    p.add_argument('--bin',default=50,type=int,
                   help='Width of bins in TES bias at which to compute figures of merit')
    p.add_argument('--rmin',default=0.1,type=float,
                   help='Approx. minimum R/Rn to accept a load curve')
    p.add_argument('--rmax',default=0.9,type=float,
                   help='Approx. maximum R/Rn at which to accept a load curve')
    p.add_argument('--Nmin',default=2,type=int,
                   help='Approx. minimum number of TESs required for tuning figure-of-merit')
    p.add_argument('--verbose',default=False,type=bool,
                   help='Should I print intermediate messages?')
    args = p.parse_args()

    # Load the IV curve
    if os.path.isfile(args.iv):
        ivname = args.iv
    elif os.path.isfile(os.path.join('/data/mce/ivcurves',args.iv)):
        ivname = os.path.join('/data/mce/ivcurves',args.iv)
    else:
        sys.exit('Tuning directory not found')
    if args.verbose:
        print 'Using IV curve %s'%(os.path.abspath(ivname))
    try:
        iv = _miniIVcurve(ivname)
    except Exception:
        sys.exit('Failed to load IV curve')
    bias=choose_biases(iv,window=args.window,bias_bin=args.bin,
                       rfrac=[args.rmin,args.rmax],Nthresh=args.Nmin)
    print ''.join(['%d '%b for b in bias])


if __name__ == '__main__':
    main()
