#!/usr/bin/perl -w

use strict;

my ($np, $ns, $nr, $nv, $nx) = (0, 0, 0, 0, 0);
my (@p, @sysn, @rcan, @sysp, @rcap, @v);

my %cn = (
  ac  => "AC",
  bc1 => "B1",
  bc2 => "B2",
  cc  => "CC",
  rc1 => "R1",
  rc2 => "R2"
);

my %pn = (
  cards_to_report     => "cards_to_reprt",
  ramp_step_phase     => "ramp_step_phas",
  tck_half_period     => "tck_hlf_period",
  enbl_flux_fb_mod    => "enb_flx_fb_mod",
  pterm_decay_bits    => "ptrm_dcay_bits",
  ramp_step_period    => "rmp_stp_period",
  internal_cmd_mode   => "intrnl_cmd_mod",
  num_cols_reported   => "num_col_report",
  num_rows_reported   => "num_row_report",
  readout_col_index   => "rdout_col_indx",
  readout_row_index   => "rdout_row_indx",
  ramp_step_data_num  => "rmp_stp_dat_no",
  rcs_to_report_data  => "rcs_to_rep_dat",
  awg_sequence_length => "awg_seqnce_len"
);

my $angry_warning = "/* This file is automatically generated.  "
. "Changes made here will be lost! */\n";

sub mce_derived_inc {
  open OUT, ">../spider_config/mce_derived.inc" or die "$!";
  select OUT;
  my @m = (1 .. 6);

  print $angry_warning;
  my $t = $nx * 6;
  for my $m (@m) {
    for (@p) {
      my $p = (exists $pn{$$_[1]}) ? $pn{$$_[1]} : $$_[1];
      my $c = $cn{$$_[0]};
      die $$_[0] unless $cn{$$_[0]};
      if ($$_[2] == 1) {
        my $n = $$_[4] + $nx * ($m - 1);
        print "  MPLEX(\"$m$c$p\", \"mce_mplex\", \"mce_index\", ",
        "$n, $t),\n";
      } else {
        $p .= "," while (length($p) < 14);
        for (my $i = 0; $i < $$_[2]; ++$i) {
          my $fi = ($$_[2] > 9 and $i < 10) ? "0$i" : $i;
          my $n = $$_[4] + $nx * ($m - 1) + $i;
          print "  MPLEX(\"$m$c$p$fi\", \"mce_mplex\", ",
          "\"mce_index\", $n, $t),\n";
        }
      }
    }
  }

  select STDOUT;
}


sub mce_counts_h {
  open OUT, ">mce_counts.h.new" or die "$!";
  select OUT;

  print $angry_warning;
  print "#define N_MCE_PHYS $np\n";
  print "#define N_MCE_SYS  $ns\n";
  print "#define N_MCE_RCA  $nr\n";
  print "#define N_MCE_VIRT $nv\n";
  print "#define N_MCE_STAT $nx\n";
  select STDOUT;
}

sub mce_struct_c {
  my $f = 1;
  open OUT, ">mce_struct.c" or die "$!";
  select OUT;

  print $angry_warning;
  print "#include \"mce_struct.h\"\n";
  print "const struct ms_phys mstat_phys[N_MCE_PHYS] = {";
  for (@p) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],$$_[3],$$_[4]}";
  }
  print "};\n";
  print "const struct ms_virt mstat_virt[N_MCE_VIRT] = {";
  $f = 1;
  for (@v) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],{";
    print "{$$_[3],$$_[4],\"$$_[5]\",\"$$_[6]\",$$_[7]},";
    print "{$$_[8],$$_[9],\"$$_[10]\",\"$$_[11]\",$$_[12]}}}";
  }
  print "};\n";
  print "const int sys_param[N_MCE_SYS] = {", join(",", @sysp), "};\n";
  print "const char *const sys_name[N_MCE_SYS] = {\"", join("\",\"", @sysn),
  "\"};\n";
  print "const int rca_param[N_MCE_RCA] = {", join(",", @rcap), "};\n";
  print "const char *const rca_name[N_MCE_RCA] = {\"", join("\",\"", @rcan),
  "\"};\n";

  select STDOUT;
}

while (<>) {
  next if /Hardware file:/;
  next if /maps:$/;

  if (/physical +([^ ]+) +([^ ]+) +x0*([0-9]+) +(0x[0-9A-Fa-f]+) +([0-9]+) +cards: (.+)/) {
    next if ($1 eq "psc");
    next if ($1 eq "rcs");

    if ($1 eq "rca") {
      push @rcan, $2;
      push @rcap, $4;
      $nr++;
    } elsif ($1 eq "sys") {
      push @sysn, $2;
      push @sysp, $4;
      $ns++;
    } else {
      my $n = $3;
      $n = 33 if ($n == 41);
      push @p, [ $1, $2, $n, $4, $nx, $6 ];
      $np++;
      $nx += $n;
    }
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, 0, 0, "", "", 0 ];
    $nv++;
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\] \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13 ];
    $nv++;
  } else {
    die $_;
  }
}

&mce_struct_c;
&mce_counts_h;
&mce_derived_inc;
