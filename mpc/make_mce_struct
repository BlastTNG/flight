#!/usr/bin/perl -w

use strict;

my ($np, $ns, $nv, $nx) = (0, 0, 0, 0);
my (@p, @sysn, @v);
my (%lp, %fp);

my $angry_warning = "/* This file is automatically generated.  "
. "Changes made here will be lost! */\n";

sub format_mce_mplex {
  open OUT, ">../spider_etc/format.mce_mplex" or die "$!";
  select OUT;
  my @m = (1 .. 6);

  print "# This file is automatically generated.\n";
  print "# To regenerate this file, build mpc on a MCC.\n";
  my $t = $nx * 6;
  for my $m (@m) {
    for (@p) {
      if ($$_[3] == 1) {
        my $n = $$_[5] + $nx * ($m - 1);
        print "MCE$m:$$_[0]:$$_[1] MPLEX mce_mplex mce_index $n $t\n";
      } else {
        for (my $i = 0; $i < $$_[3]; ++$i) {
          my $fi = ($$_[2] > 9 and $i < 10) ? "0$i" : $i;
          my $n = $$_[5] + $nx * ($m - 1) + $i;
          print "MCE$m:$$_[0]:$$_[1]($fi) MPLEX mce_mplex mce_index $n $t\n";
        }
      }
    }
  }

  select STDOUT;
}


sub mce_counts_h {
  open OUT, ">mce_counts.h.new" or die "$!";
  select OUT;

  print $angry_warning;
  print "#define N_MCE_PHYS $np\n";
  print "#define N_MCE_SYS  $ns\n";
  print "#define N_MCE_VIRT $nv\n";
  print "#define N_MCE_STAT $nx\n";
  print "\n";
  for (keys %fp) {
    print "#define FIRST_$_" . "_PARAM $fp{$_}\n";
    print "#define  LAST_$_" . "_PARAM $lp{$_}\n";
  }
  select STDOUT;
}

sub mce_struct_c {
  my $f = 1;
  open OUT, ">mce_struct.c" or die "$!";
  select OUT;

  print $angry_warning;
  print "#include \"mce_struct.h\"\n";
  print "const struct ms_phys mstat_phys[N_MCE_PHYS] = {";
  for (@p) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],$$_[3],$$_[4],$$_[5]}";
  }
  print "};\n";
  print "const struct ms_virt mstat_virt[N_MCE_VIRT] = {";
  $f = 1;
  for (@v) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],{";
    print "{$$_[3],$$_[4],\"$$_[5]\",\"$$_[6]\",$$_[7]},";
    print "{$$_[8],$$_[9],\"$$_[10]\",\"$$_[11]\",$$_[12]}}}";
  }
  print "};\n";
  print "const char *const mstat_sys[N_MCE_SYS] = {\"", join("\",\"", @sysn),
  "\"};\n";

  select STDOUT;
}

while (<>) {
  next if /Hardware file:/;
  next if /maps:$/;
  next if / ! /;

  if (/physical +([^ ]+) +([^ ]+) +x0*([0-9]+) +(0x[0-9A-Fa-f]+) +([0-9]+) +cards: (.+)/) {
    next if ($1 eq "psc");
    next if ($1 eq "rcs");
    next if ($1 eq "rca");

    if ($1 eq "sys") {
      push @sysn, $2;
      $ns++;
    } else {
      my $n = ($3 == 41) ? 33 : $3;
      $fp{uc $1} = $np unless(exists $fp{uc $1});
      $lp{uc $1} = $np;
      push @p, [ $1, $2, $3, $n, $4, $nx, $6 ];
      $np++;
      $nx += $n;
    }
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, 0, 0, "", "", 0 ];
    $nv++;
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\] \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13 ];
    $nv++;
  } else {
    die $_;
  }
}

&mce_struct_c;
&mce_counts_h;
&format_mce_mplex;;
