#!/usr/bin/perl -w
# make_mce_struct: read mce.cfg and experiment.cfg and make the autogenerated
# files
#
# Copyright (C) 2013, D. V. Wiebe
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


use strict;

my ($ne, $np, $ns, $nv, $nx) = (0, 0, 0, 0, 0);
my (@p, @sysn, @v, @eb, @e);
my (%lp, %fp);
my (%lm, %fm);

my $angry_warning = "/* This file is automatically generated.  "
. "Changes made here will be lost! */\n";

sub printexp {
  my ($pre, $name, $r, $i, $t, @p) = @_;
  print "$pre$name MPLEX mce_mplex mce_index $i $t\n";
  if ($p[1] eq "BIT") {
    print "$pre$$_[0] BIT $pre$name $$_[1]\n" for (@eb);
  } elsif ($p[1] eq "BITARR") {
    if ($p[3] == 1) { # just columns
      for (my $c = 0; $c < 16; ++$c) {
        printf "$pre$$_[0](c%02i) BIT $pre$name $c\n", $c
      }
    } else { # r/c bitfield
      for (my $c = 0; $c < 16; ++$c) {
        printf "$pre$$_[0](r%02ic%02i) BIT $pre$name $c\n", $r, $c
      }
    }
  } elsif ($p[1] eq "FLOAT") {
    my $b = $p[4];
    my $m = ($p[5] - $p[4]) / 65535.;
    print $pre . (uc $$_[0]) . " LINCOM $pre$name $m $b\n";
  } elsif ($p[1] eq "INT") {
    if ($p[3] == 528) { # rows and columns
      my $rr = ($r % 33);
      my $c = int($r / 33);
      printf "/ALIAS $pre$$_[0](r%02ic%02i) $pre$name\n", $rr, $c;
    }
  } else {
    die @p;
  }
}

sub format_mce_mplex {
  open OUT, ">../spider_etc/format.mce_mplex" or die "$!";
  select OUT;
  my @m = (1 .. 6);
  my $nn = $nx + $ne;

  print "# This file is automatically generated.\n";
  print "# To regenerate this file, build mpc on a MCC.\n";
  my $t = $nn * 6;
  for my $m (@m) {
    for (@p) {
      if ($$_[3] == 1) {
        my $n = $$_[5] + $nn * ($m - 1);
        print "X$m:$$_[0]:$$_[1] MPLEX mce_mplex mce_index $n $t\n";
      } else {
        for (my $i = 0; $i < $$_[3]; ++$i) {
          my $fi = ($$_[3] > 9 and $i < 10) ? "0$i" : $i;
          my $n = $$_[5] + $nn * ($m - 1) + $i;
          print "X$m:$$_[0]:$$_[1]($fi) MPLEX mce_mplex mce_index $n $t\n";
        }
      }
    }
    for (@v) {
      my $n = $$_[2];
      $n = 33 if ($n == 41);
      if ($n == 1) {
        my $fi = ($$_[7] < 10) ? "0$$_[7]" : $$_[7];
        print "/ALIAS X$m:$$_[0]:$$_[1] X$m:$$_[5]:$$_[6]($fi)\n";
      } else {
        for (my $i = 0; $i < $n; ++$i) {
          my $fi = ($i < 10) ? "0$i" : $i;
          if ($i < $$_[4]) {
            # map 1
            my $j = ($$_[7] + $i);
            $j = "0$j" if ($j < 10 and $$_[4] > 9);
            print "/ALIAS X$m:$$_[0]:$$_[1]($fi) X$m:$$_[5]:$$_[6]($j)\n";
          } else {
            # map 2
            my $j = ($$_[12] + $i - $$_[8]);
            $j = "0$j" if ($j < 10 and $$_[9] > 9);
            print "/ALIAS X$m:$$_[0]:$$_[1]($fi) X$m:$$_[10]:$$_[11]($j)\n";
          }
        }
      }
    }
    for (@e) {
      my $n = $nx + $$_[2] + $nn * ($m - 1);
      if ($$_[3] == 1) {
        printexp("X$m:exp:", $$_[0], 0, $n, $t, @$_);
      } else {
        for (my $i = 0; $i < $$_[3]; ++$i) {
          my $fi = ($$_[3] > 9 and $i < 10) ? "0$i" : $i;
          my $cn = $n + $i;
          printexp("X$m:exp:", "$$_[0]($fi)", $i, $cn, $t, @$_);
        }
      }
    }
  }

  select STDOUT;
}


sub mce_counts_h {
  open OUT, ">mce_counts.h.new" or die "$!";
  select OUT;

  print $angry_warning;
  print "#define N_MCE_PHYS $np\n";
  print "#define N_MCE_SYS  $ns\n";
  print "#define N_MCE_VIRT $nv\n";
  print "#define N_EXP_CFG  $ne\n";
  print "#define N_EXP_OFF  $nx\n";
  print "#define N_MCE_STAT ", ($nx + $ne), "\n";
  print "\n";
  for (keys %fp) {
    print "#define FIRST_$_" . "_PARAM $fp{$_}\n";
    print "#define  LAST_$_" . "_PARAM $lp{$_}\n";
  }
  print "\n";
  for (keys %fm) {
    print "#define FIRST_$_" . "_MAP $fm{$_}\n";
    print "#define  LAST_$_" . "_MAP $lm{$_}\n";
  }
  select STDOUT;
}

sub mce_struct_c {
  my $f = 1;
  open OUT, ">mce_struct.c" or die "$!";
  select OUT;

  print $angry_warning;
  print "#include \"mce_struct.h\"\n";
  print "const struct ms_phys mstat_phys[N_MCE_PHYS] = {";
  for (@p) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],$$_[3],$$_[4],$$_[5]}";
  }
  print "};\n";
  print "const struct ms_virt mstat_virt[N_MCE_VIRT] = {";
  $f = 1;
  for (@v) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],{";
    print "{$$_[3],$$_[4],\"$$_[5]\",\"$$_[6]\",$$_[7]},";
    print "{$$_[8],$$_[9],\"$$_[10]\",\"$$_[11]\",$$_[12]}}}";
  }
  print "};\n";
  print "const char *const mstat_sys[N_MCE_SYS] = {\"", join("\",\"", @sysn),
  "\"};\n";

  select STDOUT;
}

open IN, "<mce_status.g" or die "can't open mce_status.g";
while (<IN>) {
  next if /Hardware file:/;
  next if /maps:$/;
  next if / ! /;

  if (/physical +([^ ]+) +([^ ]+) +x0*([0-9]+) +(0x[0-9A-Fa-f]+) +([0-9]+) +cards: (.+)/) {
    next if ($1 eq "psc");
    next if ($1 eq "rcs");
    next if ($1 eq "rca");

    if ($1 eq "sys") {
      push @sysn, $2;
      $ns++;
    } else {
      my $n = ($3 == 41) ? 33 : $3;
      $n = 16 if ($n == 32 and $2 ne "flux_fb");
      $fp{uc $1} = $np unless(exists $fp{uc $1});
      $lp{uc $1} = $np;
      push @p, [ $1, $2, $3, $n, $4, $nx, $6 ];
      $np++;
      $nx += $n;
    }
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    $fm{uc $1} = $nv unless(exists $fm{uc $1});
    $lm{uc $1} = $nv;
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, 0, 0, "", "", 0 ];
    $nv++;
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\] \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    $fm{uc $1} = $nv unless(exists $fm{uc $1});
    $lm{uc $1} = $nv;
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13 ];
    $nv++;
  } else {
    die $_;
  }
}

open IN, "<expcfg_list.c" or die "can't open expcfg_list.c";
my $l = -1;
while (<IN>) {
  next unless /^  {/;
  last if /\{0}/;

  if (/  {"([^"]*)", CFGSER_BIT, 0, ([0-9]*)}/) {
    if ($2 eq 0) {
      push @e, [ "expcfg_bits", "BIT", 0, 1];
      $ne++;
    }
    push @eb, [ $1, $2];
  } elsif (/  {"([^"]*)", *CFGSER_(BITARR|INT), *([0-9]*), *([0-9]*)}/) {
    push @e, [ $1, $2, $3, $4 ];
    $ne += $4;
    $l = $3 + $4;
  } elsif (/  {"([^"]*)", CFGSER_FLOAT, ([0-9]*), ([0-9]*), ([0-9.-]*), ([0-9.-]*)}/) {
    push @e, [ $1, "FLOAT", $2, $3, $4, $5 ];
    $ne += $3;
    $l = $2 + $3;
  } else {
    die $_;
  }
}
die "Count mismatch in expcfg_list" unless ($l eq $ne);

&mce_struct_c;
&mce_counts_h;
&format_mce_mplex;
