#!/usr/bin/perl -w

use strict;

my ($ne, $np, $ns, $nv, $nx) = (0, 0, 0, 0, 0);
my (@p, @sysn, @v, @eb, @e);
my (%lp, %fp);

my $angry_warning = "/* This file is automatically generated.  "
. "Changes made here will be lost! */\n";

sub printexp {
  my ($name, $i, $t, @p) = @_;
  print "$name MPLEX mce_mplex mce_index $i $t\n";
  if ($p[1] eq "BIT") {
    for (@eb) {
      print "$$_[0] BIT $name $$_[1]\n";
    }
  } else {
#    die @p;
  }
}

sub format_mce_mplex {
  open OUT, ">../spider_etc/format.mce_mplex" or die "$!";
  select OUT;
  my @m = (1 .. 6);
  my $nn = $nx + $ne;

  print "# This file is automatically generated.\n";
  print "# To regenerate this file, build mpc on a MCC.\n";
  my $t = $nn * 6;
  for my $m (@m) {
    for (@p) {
      if ($$_[3] == 1) {
        my $n = $$_[5] + $nn * ($m - 1);
        print "X$m:$$_[0]:$$_[1] MPLEX mce_mplex mce_index $n $t\n";
      } else {
        for (my $i = 0; $i < $$_[3]; ++$i) {
          my $fi = ($$_[3] > 9 and $i < 10) ? "0$i" : $i;
          my $n = $$_[5] + $nn * ($m - 1) + $i;
          print "X$m:$$_[0]:$$_[1]($fi) MPLEX mce_mplex mce_index $n $t\n";
        }
      }
    }
    for (@e) {
      my $n = $nx + $$_[2] + $nn * ($m - 1);
      if ($$_[3] == 1) {
        printexp("X$m:exp:$$_[0]", $n, $t, @$_);
      } else {
        for (my $i = 0; $i < $$_[3]; ++$i) {
          my $fi = ($$_[3] > 9 and $i < 10) ? "0$i" : $i;
          my $cn = $n + $i;
          printexp("X$m:exp:$$_[0]($fi)", $cn, $t, @$_);
        }
      }
    }
  }

  select STDOUT;
}


sub mce_counts_h {
  open OUT, ">mce_counts.h.new" or die "$!";
  select OUT;

  print $angry_warning;
  print "#define N_MCE_PHYS $np\n";
  print "#define N_MCE_SYS  $ns\n";
  print "#define N_MCE_VIRT $nv\n";
  print "#define N_EXP_CFG  $ne\n";
  print "#define N_EXP_OFF  $nx\n";
  print "#define N_MCE_STAT ", ($nx + $ne), "\n";
  print "\n";
  for (keys %fp) {
    print "#define FIRST_$_" . "_PARAM $fp{$_}\n";
    print "#define  LAST_$_" . "_PARAM $lp{$_}\n";
  }
  select STDOUT;
}

sub mce_struct_c {
  my $f = 1;
  open OUT, ">mce_struct.c" or die "$!";
  select OUT;

  print $angry_warning;
  print "#include \"mce_struct.h\"\n";
  print "const struct ms_phys mstat_phys[N_MCE_PHYS] = {";
  for (@p) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],$$_[3],$$_[4],$$_[5]}";
  }
  print "};\n";
  print "const struct ms_virt mstat_virt[N_MCE_VIRT] = {";
  $f = 1;
  for (@v) {
    print "," unless $f;
    $f = 0;
    print "\n  {\"$$_[0]\",\"$$_[1]\",$$_[2],{";
    print "{$$_[3],$$_[4],\"$$_[5]\",\"$$_[6]\",$$_[7]},";
    print "{$$_[8],$$_[9],\"$$_[10]\",\"$$_[11]\",$$_[12]}}}";
  }
  print "};\n";
  print "const char *const mstat_sys[N_MCE_SYS] = {\"", join("\",\"", @sysn),
  "\"};\n";

  select STDOUT;
}

open IN, "<mce_status.g" or die "can't open mce_status.g";
while (<IN>) {
  next if /Hardware file:/;
  next if /maps:$/;
  next if / ! /;

  if (/physical +([^ ]+) +([^ ]+) +x0*([0-9]+) +(0x[0-9A-Fa-f]+) +([0-9]+) +cards: (.+)/) {
    next if ($1 eq "psc");
    next if ($1 eq "rcs");
    next if ($1 eq "rca");

    if ($1 eq "sys") {
      push @sysn, $2;
      $ns++;
    } else {
      my $n = ($3 == 41) ? 33 : $3;
      $fp{uc $1} = $np unless(exists $fp{uc $1});
      $lp{uc $1} = $np;
      push @p, [ $1, $2, $3, $n, $4, $nx, $6 ];
      $np++;
      $nx += $n;
    }
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, 0, 0, "", "", 0 ];
    $nv++;
  } elsif (/virtual +([^ ]+) +([^ ]+) +x0*([0-9]+) +maps: \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\] \[\(([0-9]+),([0-9]+)\)->\('([^ ]+) ([^ ]+)'\+ *([0-9]+)\)\]$/) {
    push @v, [ $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13 ];
    $nv++;
  } else {
    die $_;
  }
}

open IN, "<expcfg_list.c" or die "can't open expcfg_list.c";
my $l = -1;
while (<IN>) {
  next unless /^  {/;
  last if /\{0}/;

  if (/  {"([^"]*)", CFGSER_BIT, 0, ([0-9]*)}/) {
    if ($2 eq 0) {
      push @e, [ "expcfg_bits", "BIT", 0, 1];
      $ne++;
    }
    push @eb, [ $1, $2];
  } elsif (/  {"([^"]*)", *CFGSER_(BITARR|INT), *([0-9]*), *([0-9]*)}/) {
    push @e, [ $1, $2, $3, $4 ];
    $ne += $4;
    $l = $3 + $4;
  } elsif (/  {"([^"]*)", CFGSER_FLOAT, ([0-9]*), ([0-9]*), ([0-9.-]*), ([0-9.-]*)}/) {
    push @e, [ $1, "FLOAT", $2, $3, $4, $5 ];
    $ne += $3;
    $l = $2 + $3;
  } else {
    die $_;
  }
}
die "Count mismatch in expcfg_list" unless ($l eq $ne);

&mce_struct_c;
&mce_counts_h;
&format_mce_mplex;;
